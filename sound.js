/**
 * Handles the generation, playing, and pausing of the sound effects and background music
 * for the game.
 * 
 * The approach used is based on the following codepen post by Jack Rugile:
 * 
 * http://codepen.io/jackrugile/blog/arcade-audio-for-js13k-games
 */
$.Sound = {
  
  /**
   * Stores the sounds, keyed by the sound name.
   */
  sounds: {}, 
  
  /**
   * Initialised all of the sound effects and the background music.
   */
  init: function() {
	// TODO: Write some theme music for the game.
    // this.add('music', 1, this.song);
    this.add('hit', 10, [3,,0.1283,0.6002,0.4009,0.06,,,,,,,,,,,-0.0393,-0.2507,1,,,,,0.5]);
    this.add('explosion', 10, [3,,0.3453,0.6998,0.2278,0.08,,-0.0553,,,,-0.2784,0.6294,,,,,,1,,,,,0.52]);
    this.add('push', 1, [3,0.25,0.1706,,0.45,0.85,,0.04,0.36,,,-0.02,,,,,0.28,,1,,,0.1,,0.23]);
  },
  
  /**
   * Generates a sound using the given data and adds it to the stored sounds under the 
   * given name. It will generate the sound multiple times if count is greater than one.
   * This method handles both jsfxr sounds and SoundBox compositions.
   * 
   * @param {Object} name The name of the sound to create. This is the key in the stored sounds.
   * @param {Object} count The number of times to generate the sound.
   * @param {Object} data The data containing the parameters of the sound to be generated.
   */
  add: function(name, count, data) {
    this.sounds[name] = {tick: 0, count: count, pool: []};
    for (var i = 0; i < count; i++) {
      var audio = new Audio();
      if (data instanceof Array) {
        // If it is an Array, it must be jsfxr data.
        audio.src = jsfxr(data);
      } else {
        // Otherwise it is SoundBox data.
        var player = new CPlayer();
        player.init(data);
        // Using only 4 instruments. This saves a bit of space.
        player.generate();
        player.generate();
        player.generate();
        player.generate();
        audio.src = URL.createObjectURL(new Blob([player.createWave()], {type: "audio/wav"}));
        // This is background music, so we set it to loop and turn the volume down a bit.
        audio.loop = true;
        audio.volume = 0.35;
      }
      this.sounds[name].pool.push(audio);
    }
  },
  
  /**
   * Plays the sound of the given name. All sounds are stored as pre-generated Audio 
   * objects. So it is simply a matter of telling it to play. Some sounds have multiple
   * copies, particularly if the sound can be played in quick succession, potentially
   * overlapping. In such a case, it can't use the same Audio, so iterates over a pool
   * of Audios containing the same sound.  
   * 
   * @param {string} name The name of the sound to play.
   */
  play: function(name) {
    var sound = this.sounds[name];
    sound.pool[sound.tick].play();
    sound.tick < sound.count - 1 ? sound.tick++ : sound.tick = 0;
  },
  
  /**
   * Pauses the sound of the given name. This is only useful if the count is one, such
   * as for the background music. The current position within the Audio is also set 
   * back to the beginning so that when it is resumed, it starts at the beginning 
   * again.
   *  
   * @param {string} name The name of the sound to pause.
   */
  pause: function(name) {
    var audio = this.sounds[name].pool[0];
    audio.pause();
    audio.currentTime = 0;
  },
  
  /**
   * This is background music, composed on and generated by the SoundBox. It is an 
   * original composition composed by the author of Down The Drain.
   */
  song: {
	  // TODO
  }
};